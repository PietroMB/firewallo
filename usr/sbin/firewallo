#!/bin/bash
#Decommenta per Debug
#set -x

#Setup preliminare
ORARIO=`date`
DIRCONF="/etc/firewallo"
DIRBIN="/usr/local/firewallo/bin"
DIRLIB="/usr/local/firewallo/lib"
source $DIRCONF/firewallo.conf
source $DIRLIB/lib-wiz.sh
source $DIRLIB/lib-filter.sh

DIALOG="nano" #setta qui l'editor vi , dialog o nano se è vuoto usa vi

if [ "$DIALOG" = "" ] ; then
	DIALOG="vi"
	OPTS=""
elif [ "$DIALOG" = "nano" ] ; then
	DIALOG="nano"
	OPTS=""
elif [ "$DIALOG" = "dialog" ] ; then
	DIALOG="dialog"
	OPTS="0 0"

elif [ "$DIALOG" = "vi" ] ; then
	DIALOG="vi"
	OPTS=""
fi

# Carica il file di traduzione
load_translations() {
    local lang_file="$DIRCONF/lang/firewallo.lang.$LANG"
    if [[ -f "$lang_file" ]]; then
        source "$lang_file"
    else
        echo "LANG_NOT_FOUND"
        exit 1
    fi
}

#Funzione che apre in editor il contenuto di /etc/network/interfaces 
networking () {
    if [ "$DIALOG" = "dialog" ] ; then
		$DIALOG --backtitle CONFIGURATION_INTERFACES --title interfaces --editbox  /etc/network/interfaces  $OPTS  2> .tmp
	    RETVAL=$?
        if [ "$RETVAL" = "0" ]; then
			cat .tmp >  /etc/network/interfaces ; rm .tmp        
		fi
	else
		$DIALOG /etc/network/interfaces
	fi
}

#Funziona che apre in editor il file /etc/sysctl.conf
sysctl  () {
	if [ "$DIALOG" = "dialog" ] ; then
 		$DIALOG --backtitle CONFIGURATION_INTERFACES --title interfaces --editbox  /etc/sysctl.conf   $OPTS  2> .tmp
    	RETVAL=$?
        if [ "$RETVAL" = "0" ]; then
        	cat .tmp >  /etc/sysctl.conf ; rm .tmp
        fi     
    else
    	$DIALOG /etc/sysctl.conf
    fi
}

#Funzione che apre in editor il file di conf fi firewallo
conf () {
	if [ "$DIALOG" = "dialog" ] ; then
		$DIALOG --backtitle CONFIGURATION_EDIT --title firewallo.conf --editbox $DIRCONF/firewallo.conf  $OPTS  2> .tmp 
		RETVAL=$?
       	if [ "$RETVAL" = "0" ]; then
			cat .tmp > $DIRCONF/firewallo.conf ; rm .tmp
		fi  
    else
  		$DIALOG $DIRCONF/firewallo.conf
	fi
}

#Funzione di editing del table Filter
filter () {
MENU="
fw2fw	fw2lan		fw2wan		fw2vpns		fw2dmz		\
lan2fw	lan2lan		lan2wan		lan2vpns 	lan2dmz  	\
wan2fw	wan2lan		wan2wan		wan2vpns 	wan2dmz   	\
vpns2fw	vpns2lan	vpns2wan	vpns2vpns 	vpns2dmz 	\
dmz2fw	dmz2lan		dmz2wan		dmz2vpns 	dmz2dmz 	\
exit"

 
select opt in $MENU ; do
	if [ "$opt" = "exit" ] ; then
		main 
	else
		if [ "$DIALOG" = "dialog" ] ; then
			$DIALOG --backtitle FILTER_EDIT --title $opt --editbox $DIRCONF/filter/$opt 		$OPTS 2> .tmp 
			RETVAL=$?
           	if [ "$RETVAL" = "0" ]; then
				cat .tmp > $DIRCONF/filter/$opt ; rm .tmp
			fi			
		else
			# Esegui la lettura delle variabili dal file
			read_variables "$opt"
			# Avvia la gestione delle porte
			manage_ports "$opt"
			#$DIALOG $DIRCONF/filter/$opt 
		fi
	fi
done
}

#Funzione di editing manuale del table Nat
nat  () {
	if [ "$DIALOG" = "dialog" ] ; then
        $DIALOG --backtitle NAT_EDIT --title firewallo.nat --editbox $DIRCONF/nat/firewallo.nat  	  $OPTS 2> .tmp
		RETVAL=$?
    	if [ "$RETVAL" = "0" ]; then
			cat .tmp > $DIRCONF/nat/firewallo.nat ; rm .tmp
		fi

	else
		$DIALOG $DIRCONF/nat/firewallo.nat
	fi
}
#Funzione di editing manuale del mangle
mangle  () {
	 if [ "$DIALOG" = "dialog" ] ; then
		$DIALOG --backtitle MANGLE_EDIT --title firewallo.mangle --editbox $DIRCONF/mangle/firewallo.mangle $OPTS 2> .tmp
	    RETVAL=$?
        if [ "$RETVAL" = "0" ]; then
			cat .tmp > $DIRCONF/mangle/firewallo.mangle ; rm .tmp
		fi		
    else
		$DIALOG	$DIRCONF/mangle/firewallo.mangle
	fi
}

#Funzione di editing manuale del routing
route  () {
	if [ "$DIALOG" = "dialog" ] ; then
        $DIALOG --backtitle ROUTE_EDIT --title firewallo.route --editbox $DIRCONF/route/firewallo.route $OPTS 2> .tmp
		RETVAL=$?
        if [ "$RETVAL" = "0" ]; then
		cat .tmp > $DIRCONF/route/firewallo.route ; rm .tmp
		fi

	else
 		$DIALOG $DIRCONF/route/firewallo.route
	fi
}

#Funzione di start di Firewallo
start () {
if  [ "$NFT" != "" ] ; then
/etc/init.d/firewallo.nft start
elif [ "$IPT" != "" ]  ; then
/etc/init.d/firewallo.iptables start
fi
}

#Funzione di stop di Firewallo
stop () {
if  [ "$NFT" != "" ] ; then
/etc/init.d/firewallo.nft stop
elif [ "$IPT" != "" ] ; then
/etc/init.d/firewallo.iptables stop
fi

}

#Funzione di restart 
restart () {
stop
start
}

#Funzione di visualizzazione dello status
status () {
less $DIRCONF/status.log
}

#Funzione di list delle regole 
rules () {
if [ "$IPT" != "" ]  ;then
	$IPT -t filter 	-L -vn > .filter
	$IPT -t nat 	-L -vn > .nat
	$IPT -t mangle 	-L -vn > .mangle
elif [ "$NFT" != "" ] ; then
	$NFT list ruleset > .ruleset
fi

if [ -e .filter ] ; then
	echo "##############IPTABLES RULES##################"
	cat .filter .nat .mangle | less
fi
if [ -e .ruleset ]  ; then
	echo "#################NFT RULESET##################"
	cat .ruleset | less
fi

rm .filter .nat .mangle .ruleset 2>/dev/null
main

#done
}

#Funzione di salvataggio della configurazione di iptables/nftables ed enable del servizio su systemd
saveconf () {
restart
if [ "$IPT" != "" ] ; then
	echo "$SAVECONF_IPT_NFT"
	echo '
[Unit]
Description=Restore iptables rules
After=network.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/sbin/iptables-restore < /etc/iptables/rules.v4"
#ExecStartPost=/bin/bash -c "/sbin/ip6tables-restore < /etc/iptables/rules.v6"
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
'> /etc/systemd/system/iptables-restore.service
	systemctl daemon-reload
	systemctl disable nftables.service
	systemctl enable  iptables-restore.service
	if  [ ! -e /etc/iptables ]  ; then mkdir /etc/iptables/ ; fi
	iptables-save > /etc/iptables/rules.v4
	chmod 644 /etc/iptables/rules.v4
	echo "..OK"
elif [ "$NFT" != ""  ] ; then
	echo "Save Conf to /etc/nftables.conf and enable nftables at startup."
	systemctl disable iptables-restore.service
	systemctl enable nftables.service
	nft list ruleset > /etc/nftables.conf
	echo "..OK"
fi
}

#Funzione di switch del backend nft/iptables
nftiptables () {
echo "SELECT IPTABLES OR NFTABLES"
MENU1="iptables nftables"
opt1=""
select opt1 in $MENU1 ; do
        if [ "$opt1" = "nftables" ] ; then #se selezioni nft
        export IPT=""; #Svuoto IPT
		export NFT="/usr/sbin/nft" #Setto NFT
		sed -i 's/IPT=\"\/sbin\/iptables\"//g'  $DIRCONF/firewallo.conf #vuoto iptables in firewallo.conf
		sed -i 's/NFT=\"\/usr\/sbin\/nft\"//g'  $DIRCONF/firewallo.conf #vuoto anche nft 
		printf 'NFT=\"/usr/sbin/nft\"' >> $DIRCONF/firewallo.conf #risetto nft
		update-alternatives --set iptables /usr/sbin/iptables-nft
		systemctl enable nftables.service
		return
        elif [ "$opt1" = "iptables" ] ; then #Se selezioni iptables
        export NFT=""; #Svuoto NFT
		export IPT="/sbin/iptables" #Setto iptables
		sed -i 's/IPT=\"\/sbin\/iptables\"//g'  $DIRCONF/firewallo.conf #Vuoto iptables e anche nft
		sed -i 's/NFT=\"\/usr\/sbin\/nft\"//g'  $DIRCONF/firewallo.conf #
        printf 'IPT=\"/sbin/iptables\"' >> $DIRCONF/firewallo.conf #Setto iptables
		update-alternatives --set iptables /usr/sbin/iptables-legacy
		systemctl disable nftables.service
		systemctl enable  iptables-restore.service
		return
        fi
done
}



# Funzione per monitorare i log con Ctrl+C che uccide solo journalctl
log_filter () { 
    echo "SELECT chains do you want to view"

    MENU=("EXIT" "state" "icmp_good" "bad_tcp_flags" "POSTROUTING" "PREROUTING" "DROP" "OUTPUT_DROP" "INPUT_DROP" "FORWARD_DROP"  \
          "fw2fw" "fw2lan" "fw2wan" "fw2vpns" "fw2dmz" \
          "lan2fw" "lan2lan" "lan2wan" "lan2vpns" "lan2dmz" \
          "wan2fw" "wan2lan" "wan2wan" "wan2vpns" "wan2dmz" \
          "vpns2fw" "vpns2lan" "vpns2wan" "vpns2vpns" "vpns2dmz" \
          "dmz2fw" "dmz2lan" "dmz2wan" "dmz2vpns" "dmz2dmz" "nothing")

    
    select opt in "${MENU[@]}"; do
        if [ "$opt" = "EXIT" ]; then
            echo "Exit from filter."
            break  # Esci dal ciclo

        elif [ "$opt" = "nothing" ] && [ "$1" = "live" ]; then	
            # Mostra tutti i log in modalità live
            journalctl -k -f | less

        elif [ "$1" = "live" ] && [ "$opt" != "nothing" ]; then
            # Filtra i log live con grep
			echo "Logging $1 $opt --- Press Ctrl+C to exit"
            journalctl -k -f | grep $opt &  # Esegui in background
            PID=$!  # Salva il PID
            trap "echo 'Exit From Log ...'; kill $PID" SIGINT  # Cattura Ctrl+C
            wait $PID  # Aspetta che il processo termini
			main
        elif [ "$1" != "live" ] && [ "$opt" != "nothing" ]; then
            # Mostra i log dall'inizio di una determinata data
            journalctl -k --since "$1" | grep $opt | less

        elif [ "$1" != "live" ] && [ "$opt" = "nothing" ]; then
            # Mostra tutti i log dall'inizio di una determinata data
            journalctl -k --since "$1" | less
        fi
    done
}

# Funzione per selezionare il tipo di log
logs () {
    echo "SELECT log type"
    MENU1=("EXIT" "live" "1 week ago" "1 day ago" "1 hour ago" "1 minute ago" )
    
    select opt1 in "${MENU1[@]}"; do
		if [ "$opt1" = "EXIT" ] ; then
			main
		else
        log_filter "$opt1"
		fi
    done
}

show_wizard () {
function show_menu {
    clear
    echo "======================================"
    echo "         FIREWALLO WIZARD MENU        "
    echo "======================================"
    echo "1) Filter Wizard"
    echo "2) Nat Prerouting Wizard"
    echo "3) Nat Postrouting Wizard"
	echo "4) WireGuard" 
    echo "5) Exit"
    echo "======================================"
    echo -n "Select an option: "
}

# Funzioni per le diverse opzioni
function filter_wizard {
    $DIRBIN/wiz/magic_filter.sh
}

function nat_prerouting_wizard {
	$DIRBIN/wiz/magic_nat_prerouting.sh
}

function nat_postrouting_wizard {
    $DIRBIN/wiz/magic_nat_postrouting.sh
}

function wg_manager_wizard {
    $DIRBIN/wiz/wg/wg_manager.sh
}



# Ciclo principale del menu
while true
do
    show_menu
    read option

    case $option in
        1)
            filter_wizard
            ;;
        2)
            nat_prerouting_wizard
            ;;
        3)
            nat_postrouting_wizard
            ;;
		4)
            wg_manager_wizard
            ;;
        5)
            echo "Exit"
            break
            ;;
        *)
            echo "Select right Option!."
            ;;
    esac

    # Pausa per permettere la lettura del messaggio
    echo -n "Press Enter to continue..."
    read
done
}

#Funzione principale
main () {
clear
cat $DIRCONF/motd #Visualizza il banner motd
echo "
DEFAULT EDITOR: $DIALOG 
###########################################
"
if [[ "$NFT" = "" && "$IPT" = "" ]] ;then
	echo "You must set Backend select iptables o nftables"
fi

#Opzioni del menu
MENU="networking sysctl conf filter nat mangle start stop restart route wizard status rulesview saveconf nft-iptables logs exit"
select opt in $MENU ; do 
	if [ "$opt" = "networking" ] ; then
		networking ;  main
	elif [ "$opt" = "conf" ] ; then
		conf ; main
	elif [ "$opt" = "sysctl" ] ; then
        sysctl ; main
	elif [ "$opt" = "filter" ] ; then
        filter ; main
    elif [ "$opt" = "nat" ] ; then
        nat ; main
	elif [ "$opt" = "mangle" ] ; then
        mangle ; main
	elif [ "$opt" = "start" ] ; then
        start ; echo "PRESS ENTER" ;read INVIO >> /dev/null 2>&1 ;main #starto attendo e leggo invio per tornare
	elif [ "$opt" = "stop" ] ; then
        stop ; echo "PRESS ENTER" ;read INVIO >> /dev/null 2>&1 ;main #idem come sopra
	elif [ "$opt" = "restart" ] ; then 
        restart ; echo "PRESS ENTER" ;read INVIO >> /dev/null 2>&1 ;main #idem come sopra
	elif [ "$opt" = "route" ] ; then
        route ; main
	elif [ "$opt" = "status" ] ; then
        status ; main
	elif [ "$opt" = "rulesview" ] ; then
        rules ; main
    elif [ "$opt" = "saveconf" ] ; then
        saveconf ; main
    elif [ "$opt" = "nft-iptables" ] ; then
        nftiptables ; main
	elif [ "$opt" = "logs" ] ; then
        logs ; main
	elif [ "$opt" = "wizard" ] ; then
		show_wizard ; main
	elif [ "$opt" = "exit" ] ; then
        echo ByeZzZ.
		exit
	fi
done
}
#Lancio finalmente il main in stile C
main
